#!/bin/sh -e

patch -p1 < fix-curl.patch

patch -p1 <<EOF
--- a/vendor/openssl-sys/build/main.rs
+++ b/vendor/openssl-sys/build/main.rs
@@ -237,6 +237,7 @@
             (3, 3, 0) => ('3', '3', '0'),
             (3, 3, 1) => ('3', '3', '1'),
             (3, 3, _) => ('3', '3', 'x'),
+            (3, 4, _) => ('3', '4', 'x'),
             _ => version_error(),
         };
 
@@ -279,7 +280,7 @@
         "
 
 This crate is only compatible with OpenSSL 1.0.1 through 1.1.1, or LibreSSL 2.5
-through 3.3.x, but a different version of OpenSSL was found. The build is now aborting
+through 3.4.x, but a different version of OpenSSL was found. The build is now aborting
 due to this version mismatch.
 
 "
EOF

patch -p1 <<EOF
--- a/compiler/rustc_session/src/config.rs
+++ b/compiler/rustc_session/src/config.rs
@@ -1512,7 +1512,7 @@
                 early_error(error_format, &format!("target file {:?} does not exist", path))
             })
         }
-        Some(target) => TargetTriple::TargetTriple(target),
+        Some(target) => TargetTriple::from_alias(target),
         _ => TargetTriple::from_triple(host_triple()),
     }
 }
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -2309,6 +2309,14 @@
         Ok(TargetTriple::TargetPath(canonicalized_path))
     }
 
+    /// Creates a target triple from its alias
+    pub fn from_alias(triple: String) -> Self {
+        match triple.as_str() {
+            "x86_64-pc-linux-musl" => TargetTriple::from_triple("x86_64-unknown-linux-musl"),
+            _ => TargetTriple::TargetTriple(triple),
+        }
+    }
+
     /// Returns a string triple for this target.
     ///
     /// If this target is a path, the file name (without extension) is returned.
--- a/compiler/rustc_target/src/spec/x86_64_unknown_linux_musl.rs
+++ b/compiler/rustc_target/src/spec/x86_64_unknown_linux_musl.rs
@@ -12,7 +12,7 @@
         SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::MEMORY | SanitizerSet::THREAD;
 
     Target {
-        llvm_target: "x86_64-unknown-linux-musl".to_string(),
+        llvm_target: "x86_64-pc-linux-musl".to_string(),
         pointer_width: 64,
         data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
             .to_string(),
EOF

# Instruct the compiler to trim absolute paths in resulting binaries and instead
# change them to relative paths ($PWD/... ./...).
export RUSTFLAGS="$RUSTFLAGS --remap-path-prefix=$PWD=."

# This package mimics the download process of rust's 'x.py'
# bootstrap library to allow for the removal of the internet
# connection requirement per build.
{
    mkdir -p "${cache_dir:=build/cache/2021-11-01}"

    for tarball in *.tar.xz\?no-extract; do
        mv -f "$tarball" "$cache_dir/${tarball%%\?no-extract}"
    done
}

# Set shared linking as the default.
for f in \
    compiler/rustc_target/src/spec/linux_musl_base.rs \
    vendor/rustc-ap-rustc_target/src/spec/linux_musl_base.rs
do
    sed 's/\(crt_static_default = \)true/\1false/' "$f" > _
    mv -f _ "$f"
done

# Ignore checksums of files modified above.
sed 's/\("files":{\)[^}]*/\1/' \
    vendor/rustc-ap-rustc_target/.cargo-checksum.json > _
mv -f _ vendor/rustc-ap-rustc_target/.cargo-checksum.json
sed 's/\("files":{\)[^}]*/\1/' \
    vendor/curl-sys/.cargo-checksum.json > _
mv -f _ vendor/curl-sys/.cargo-checksum.json
sed 's/\("files":{\)[^}]*/\1/' \
    vendor/openssl-sys/.cargo-checksum.json > _
mv -f _ vendor/openssl-sys/.cargo-checksum.json

cat > config.toml <<EOF
[llvm]
link-shared = true
skip-rebuild = true

[build]
host      = [ "x86_64-unknown-linux-musl" ]
target    = [ "x86_64-unknown-linux-musl" ]

docs           = false
compiler-docs  = false
extended       = true
submodules     = false
python         = "python3"
locked-deps    = true
vendor         = true
tools          = [ "cargo", "rustfmt" ]
sanitizers     = false
profiler       = true
full-bootstrap = false

[install]
prefix = "/usr"

[target.x86_64-unknown-linux-musl]
llvm-config = "/usr/bin/llvm-config"
crt-static  = false
sanitizers  = false

[dist]
src-tarball = false

[rust]
backtrace         = false
channel           = "stable"
codegen-tests     = false
codegen-units-std = 1
codegen-units     = 0
debug             = false
debug-assertions  = false
debuginfo-level   = 0
incremental       = false
jemalloc          = false
rpath             = false
dist-src          = false
EOF

# Workaround to get Rust to build in llvm-only environments.
# libgcc_s.so is needed for Rust's bootstrap binaries, on llvm-only systems
# this library does not exist. This hack creates it as alias to libunwind.
case $("$CC" -print-file-name=libunwind.so) in */*)
    printf 'llvm-libunwind = "system"\n' >> config.toml

    mkdir -p libgcc

    printf 'INPUT(-lunwind)\n' > \
        libgcc/libgcc_s.so

    ln -sf "$KISS_ROOT/usr/lib/libunwind.so.1" \
        libgcc/libgcc_s.so.1

    export \
        LD_LIBRARY_PATH="$PWD/libgcc:$LD_LIBRARY_PATH" \
        LIBRARY_PATH="$PWD/libgcc:$LIBRARY_PATH"
esac

./x.py build -j "$(grep -scF 'core id' /proc/cpuinfo)"
./x.py install

rm -rf \
    "$1/usr/lib/rustlib/src/" \
    "$1/usr/share/doc" \
    "$1/usr/share/zsh" \
    "$1/usr/lib/rustlib/uninstall.sh"

